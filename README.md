<div align="center">
  <h1>Examples of Different Patterns</h1>
</div>

***

## Pattern: Abstract Factory
<details>
<summary>Cross-Platform GUI Application</summary>

The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. This example demonstrates a cross-platform GUI application that uses different factories for Windows and macOS.

</details>

## Pattern: Adapter
<details>
<summary>Square Pegs in Round Holes</summary>

The Adapter pattern allows incompatible interfaces to work together. This example shows how square pegs can be adapted to fit into round holes using an adapter.

</details>

## Pattern: Bridge
<details>
<summary>Remote Control for Devices</summary>

The Bridge pattern decouples an abstraction from its implementation so that the two can vary independently. This example demonstrates a remote control that can operate different devices like a television.

</details>

## Pattern: Builder
<details>
<summary>Car Manufacturing</summary>

The Builder pattern separates the construction of a complex object from its representation. This example shows how different types of cars can be built using different builders and an automotive engineer.

</details>

## Pattern: Chain of Responsibility
<details>
<summary>Notifier Chain</summary>

The Chain of Responsibility pattern allows an object to send a command without knowing which object will handle the request. This example demonstrates a chain of notifiers that handle messages based on their priority.

</details>

## Pattern: Command
<details>
<summary>Command Executor</summary>

The Command pattern turns a request into a stand-alone object that contains all information about the request. This example shows a command executor that can perform operations like login, info, deposit, withdraw, and exit.

</details>

## Pattern: Composite
<details>
<summary>Composite Pattern Example</summary>

The Composite pattern allows you to compose objects into tree structures to represent part-whole hierarchies. This example demonstrates how individual objects and compositions of objects can be treated uniformly.

</details>

## Pattern: Decorator
<details>
<summary>Decorator Pattern Example</summary>

The Decorator pattern allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class. This example shows how additional functionalities can be added to objects dynamically.

</details>

## Pattern: Exceptions
<details>
<summary>Custom Exceptions</summary>

This package contains custom exceptions used across different patterns and examples in the project. It demonstrates how to create and use custom exceptions to handle specific error conditions.

</details>

## Pattern: Facade
<details>
<summary>Facade Pattern Example</summary>

The Facade pattern provides a simplified interface to a complex subsystem. This example shows how a facade can be used to interact with a complex system in a simplified manner.

</details>

## Pattern: Factory Method
<details>
<summary>Factory Method Pattern Example</summary>

The Factory Method pattern defines an interface for creating an object, but lets subclasses alter the type of objects that will be created. This example demonstrates how different products can be created using factory methods.

</details>

## Pattern: Flyweight
<details>
<summary>Flyweight Pattern Example</summary>

The Flyweight pattern is used to minimize memory usage by sharing as much data as possible with similar objects. This example shows how flyweights can be used to reduce memory consumption.

</details>

## Pattern: Interpreter
<details>
<summary>String Calculator Realization with Interpreter Pattern</summary>

The Interpreter pattern is used to define a grammatical representation for a language and provides an interpreter to deal with this grammar. In this example, a string calculator is implemented using the Interpreter pattern.

</details>

## Pattern: Iterator
<details>
<summary>Iterator Pattern Example</summary>

The Iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. This example demonstrates how iterators can be used to traverse collections.

</details>

## Pattern: Mediator
<details>
<summary>Mediator Pattern Example</summary>

The Mediator pattern is used to reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.

</details>

## Pattern: Prototype
<details>
<summary>Prototype Pattern Example</summary>

The Prototype pattern is used to create new objects by copying an existing object, known as the prototype. This example demonstrates how objects can be cloned to create new instances.

</details>

## Pattern: Proxy
<details>
<summary>Proxy Pattern Example</summary>

The Proxy pattern provides a surrogate or placeholder for another object to control access to it. This example shows how a proxy can be used to control access to a resource.

</details>

## Pattern: Singleton
<details>
<summary>Singleton Pattern Example</summary>

The Singleton pattern ensures that a class has only one instance and provides a global point of access to it. This example demonstrates how to implement a thread-safe singleton using double-checked locking.

</details>

## Pattern: State
<details>
<summary>Name in Different Cases Depends on the State</summary>

The State pattern allows an object to alter its behavior when its internal state changes. This example demonstrates how a name can be represented in different cases depending on the state.

</details>

<details>
<summary>Trucks with Four States</summary>

This example illustrates the State pattern with trucks that can be in one of four states: on base, on route, on repair, or on parking.

</details>

## Pattern: Strategy
<details>
<summary>Strategy Pattern Example</summary>

The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. This example shows how different strategies can be used to perform a task.

</details>

## Pattern: Template
<details>
<summary>Template Method Pattern Example</summary>

The Template Method pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses. This example demonstrates how the template method can be used to define an algorithm's structure.

</details>

## Pattern: Visitor
<details>
<summary>Visitor Pattern Example</summary>

The Visitor pattern allows you to add further operations to objects without having to modify them. This example shows how visitors can be used to perform operations on elements of an object structure.

</details>